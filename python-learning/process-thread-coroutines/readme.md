# 1. 进程（Process）

进程是操作系统中资源分配的基本单位，每个进程都有自己的内存空间、数据和代码。不同进程之间相互独立，通信比较复杂。多进程适合用于计算密集型任务，因为每个进程可以在不同的 CPU 上运行，充分利用多核处理器。

## 1.1 fork 实现多进程

Unix/Linux操作系统提供了一个fork()系统调用，fork() 操作系统自动把当前进程（称为父进程）复制了一份（称为子进程）。
通过 fork 调用，进程在接到新任务时能派生子进程处理。Apache 服务器通过父进程监听端口，收到请求时 fork 子进程处理。
os.fork() 是一个系统调用，用于创建一个新的子进程。它在当前进程（父进程）上调用，并返回两次：

  - 在父进程中返回子进程的进程ID（PID）
  - 在子进程中返回 0,表示它是一个子进程。

## 1.2 multiprocessing 跨平台实现多进程

编写多进程服务程序，Unix/Linux无疑是最佳选择，因为Windows不支持 fork 调用。不过，Python作为跨平台语言，通过 multiprocessing 模块提供了跨平台的多进程支持。

## 1.3 multiprocessing pool 进程池

如果要启动大量的子进程，可以用进程池的方式批量创建子进程

  - pool = multiprocessing.Pool(3) 表示最多同时执行3个进程。这是Pool设计的限制，并不是操作系统的限制。Pool的默认大小是CPU的核数。
  - pool.join()等待所有子进程执行完毕，调用join()之前必须先调用close()
  - pool.close()调用之后就不能继续添加新的Process

## 1.4 subprocess 子进程

当子进程是一个外部进程。通常需要控制子进程的输入和输出。subprocess模块可以方便地启动一个子进程，然后控制其输入和输出。


## 1.5 IPC 进程之间的通信

在 Python 中，进程间通信（Inter-Process Communication，简称 IPC）通常是指不同进程之间交换数据的机制。由于每个进程都有自己的内存空间，不能直接共享数据，因此需要使用专门的 IPC 方法来实现数据传递。
Python 提供了几种常用的进程间通信方式，主要通过 multiprocessing 模块来实现。常见的进程间通信方式包括：

  - Queue：适用于多个进程间的消息传递，支持先进先出（FIFO）的方式。
  - Pipe：适用于两个进程之间的双向通信。
  - Value 和 Array：适用于简单数据类型（如整数、浮点数）的共享内存。
  - Manager：适用于复杂的数据结构（如字典、列表等）的共享。


# 2. 线程（Thread）

进程由若干线程组成，每个进程至少有一个线程，多任务可以通过多进程或单个进程内的多线程来实现。
由于线程是操作系统原生支持的执行单元，因此，许多高级编程语言，包括Python，都内置了多线程的支持。Python的线程是基于POSIX线程（真实的操作系统线程），而非模拟的线程。

## 2.1 线程锁 Lock

多线程和多进程的主要区别在于，多进程中每个进程有独立的变量拷贝，互不影响；而多线程中，所有线程共享同一变量，因此多个线程同时修改同一变量可能导致数据混乱。

## 2.2 多核 CPU

启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有102%，也就是仅使用了一核。
而如果使用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？
因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。
GIL是Python解释器设计的问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。
所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现。
Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。

## 2.3 ThreadLocal

在Python中，ThreadLocal是threading模块提供的一个类，用于在不同线程之间保持独立的数据。每个线程可以在ThreadLocal对象中存储自己的独立数据，这些数据对其他线程是不可见的。可通过ThreadLocal对象的_thread_local属性来存取属于该线程的特有数据
ThreadLocal使用场景：为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等。


# 3. Process vs Thread

## 3.1 Master-Worker 模式

实现多任务通常采用 Master-Worker 模式

  - Master 负责分配任务。
  - Worker 负责执行任务。

在不同的实现方式下，Master 和 Worker 的角色有所不同：

  - 多进程模式：主进程是 Master，其他进程是 Worker。
    优点： 稳定性高：子进程崩溃不会影响主进程。进程相互独立，减少了线程间的资源冲突。
    缺点：创建进程开销大，尤其在 Windows 下。操作系统能同时运行的进程数量有限，过多进程会影响系统调度。
  - 多线程模式：主线程是 Master，其他线程是 Worker。
    优点： 效率较高，特别在 Windows 下。
    缺点： 稳定性差：任何一个线程崩溃可能导致整个进程崩溃，因为所有线程共享进程的内存。
    应用：微软的 IIS 服务器采用多线程模式，但由于稳定性差，后来采取了混合模式。

## 3.2 线程切换的开销

无论多进程还是多线程，任务过多时，线程切换的开销会影响效率。
假设有多项任务，切换任务需要保存和恢复状态，类似操作系统在切换进程或线程时所做的工作。如果任务数量过多，系统可能会把大部分时间花费在任务切换上，导致效率下降，最常见的现象是硬盘狂响，系统假死。

## 3.3 计算密集型 vs IO 密集型任务

任务的类型决定是否需要多任务支持：
  - 计算密集型任务
    特点：需要大量的 CPU 计算，如圆周率计算、视频解码等。
    适合场景：任务数量应等于 CPU 核心数，任务越多，切换的开销越大，效率下降。
    语言选择：Python 不适合处理计算密集型任务，C 语言更适合。
  - IO 密集型任务
    特点：涉及大量网络、磁盘 IO 操作，CPU 消耗较少。
    适合场景：Web 应用等，任务越多，CPU 效率越高，但也有上限。
    语言选择：Python 等脚本语言非常适合 IO 密集型任务。
  - 异步 IO
    由于 CPU 和 IO 操作速度差异，单进程单线程模型会导致任务无法并行执行。为此，现代操作系统支持 异步 IO，允许单进程处理多个任务，从而提高效率。
  - 事件驱动模型
    例子：Nginx 使用事件驱动模型，单进程就能高效支持多任务。
    在多核 CPU 上，Nginx 可以使用多个进程来充分利用多核性能。
  - Python 协程
    协程是单线程异步编程模型，使得多任务编程更高效。
    通过协程，可以在单线程中高效处理多任务，广泛应用于 IO 密集型任务。
  - 分布式进程
    Thread和Process中，应当优选Process，因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。
    Python的 multiprocessing 模块不但支持多进程，其中managers 子模块还支持把多进程分布到多台机器上。一个服务进程可以作为调度者，将任务分布到其他多个进程中。


# 4. 协程（coroutines）

Python 中的 协程（coroutines） 又称微线程，纤程，是一种用于实现并发操作的编程方式，它是基于生成器（generator）和 asyncio 库的一种异步编程模型。协程可以使得 Python 在处理 I/O 密集型任务时，不需要等待任务完成，可以继续处理其他任务。
Python中的协程是基于generator实现的，在 generator 中，我们不但可以通过 for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值。
协程本质上是一种 可暂停和恢复执行的函数，通常在执行过程中遇到 await 关键字时挂起，等到某个操作完成后再继续执行。
